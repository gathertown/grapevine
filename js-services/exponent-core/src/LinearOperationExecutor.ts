/**
 * Linear operation executor
 * Ported from @exponent/task-extraction
 *
 * Executes Linear operations (CREATE/UPDATE/SKIP) using the Linear SDK.
 */

import { LinearClient } from '@linear/sdk';
import { z } from 'zod';
import { LinearOperation, ExecutionResult, ExecutionSummary, TaskAction } from './types';
import { createLogger } from '@corporate-context/backend-common';
const logger = createLogger('exponent-core');
import { switchEnv } from '@corporate-context/backend-common';

const shouldAddLabel = switchEnv({
  local: false,
  staging: true,
  production: false,
});

/**
 * Zod schema for Linear issue creation input
 * Transforms null values to undefined (Linear SDK requirement)
 */
const LinearIssueCreateInputSchema = z.object({
  title: z.string(),
  description: z.string(),
  teamId: z.string(),
  assigneeId: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  priority: z
    .number()
    .min(1)
    .max(4)
    .nullish()
    .transform((v) => v ?? undefined),
  dueDate: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  projectId: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  labelIds: z
    .array(z.string())
    .nullish()
    .transform((v) => v ?? undefined),
  stateId: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
});

/**
 * Zod schema for Linear issue update input
 * Transforms null values to undefined (Linear SDK requirement)
 */
const LinearIssueUpdateInputSchema = z.object({
  title: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  description: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  assigneeId: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  priority: z
    .number()
    .min(1)
    .max(4)
    .nullish()
    .transform((v) => v ?? undefined),
  dueDate: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
  stateId: z
    .string()
    .nullish()
    .transform((v) => v ?? undefined),
});

/**
 * Linear operation executor
 *
 * Takes operations generated by the triage agent and executes them
 * using the Linear SDK.
 */
export class LinearOperationExecutor {
  private client: LinearClient;
  private linearTeamId: string;

  constructor(apiKeyOrAccessToken: string, linearTeamId: string) {
    // Linear API keys start with "lin_api_", OAuth tokens don't
    const isApiKey = apiKeyOrAccessToken.startsWith('lin_api_');
    this.client = isApiKey
      ? new LinearClient({ apiKey: apiKeyOrAccessToken })
      : new LinearClient({ accessToken: apiKeyOrAccessToken });
    this.linearTeamId = linearTeamId;
  }

  /**
   * Create an attachment on a Linear issue
   *
   * @param issueId - Linear issue ID
   * @param title - Attachment title
   * @param url - Attachment URL
   * @param subtitle - Optional subtitle
   * @returns Attachment ID if successful
   */
  async createAttachment(
    issueId: string,
    title: string,
    url: string,
    subtitle?: string
  ): Promise<string | undefined> {
    try {
      const attachmentPayload = await this.client.createAttachment({
        issueId,
        title,
        url,
        subtitle,
      });
      const attachment = await attachmentPayload.attachment;
      return attachment?.id;
    } catch (error) {
      logger.error('Failed to create Linear attachment', {
        issueId,
        url,
        error: error instanceof Error ? error.message : String(error),
      });
      return undefined;
    }
  }

  /**
   * Execute a single Linear operation
   *
   * @param operation - Operation to execute
   * @returns Result with success status and issue ID
   */
  async executeOperation(operation: LinearOperation): Promise<ExecutionResult> {
    try {
      switch (operation.action) {
        case TaskAction.CREATE: {
          if (!operation.createData) {
            throw new Error('CREATE operation missing createData');
          }

          // Set the Linear team ID from the mapping
          operation.createData.teamId = this.linearTeamId;

          // Validate and transform data using Zod (converts null to undefined)
          const createInput = LinearIssueCreateInputSchema.parse(operation.createData);

          if (shouldAddLabel) {
            const EXPONENT_LABEL_ID = '983dd23d-b314-463c-a333-b834a8677111';
            const existingLabelIds = createInput.labelIds || [];
            if (!existingLabelIds.includes(EXPONENT_LABEL_ID)) {
              createInput.labelIds = [...existingLabelIds, EXPONENT_LABEL_ID];
            }
          }

          const createPayload = await this.client.createIssue(createInput);
          const createdIssue = await createPayload.issue;
          const linearIssueId = createdIssue?.id;
          const linearIssueIdentifier = createdIssue?.identifier;

          return {
            operation,
            success: true,
            linearIssueId,
            linearIssueIdentifier,
            linearIssueUrl: createdIssue?.url ?? undefined,
            linearIssueTitle: createdIssue?.title ?? undefined,
          };
        }

        case TaskAction.UPDATE: {
          if (!operation.updateData) {
            throw new Error('UPDATE operation missing updateData');
          }
          const {
            issueId,
            descriptionAppend,
            documentId: _documentId,
            duplicateDescription: _duplicateDescription,
            relatedTickets: _relatedTickets,
            reason: _reason,
            ...updateFields
          } = operation.updateData;

          // Fetch the issue to check its current state before updating
          const existingIssue = await this.client.issue(issueId);
          if (!existingIssue) {
            logger.error('Cannot update issue: issue not found', { issueId });
            return {
              operation,
              success: false,
              error: `Issue ${issueId} not found`,
            };
          }

          // Check if issue is in a terminal state (done or canceled)
          // Linear state.type is one of: "triage", "backlog", "unstarted", "started", "completed", "canceled"
          const issueState = await existingIssue.state;
          const stateType = issueState?.type;

          if (stateType === 'completed' || stateType === 'canceled') {
            logger.error('Cannot update issue: issue is already in done or canceled state', {
              issueId,
              issueIdentifier: existingIssue.identifier,
              stateName: issueState?.name,
              stateType,
            });
            return {
              operation,
              success: false,
              error: `Issue ${existingIssue.identifier} is already in "${issueState?.name}" state and cannot be modified`,
              linearIssueId: issueId,
              linearIssueIdentifier: existingIssue.identifier,
              linearIssueUrl: existingIssue.url,
              linearIssueTitle: existingIssue.title,
            };
          }

          let descriptionUpdated = false;

          // Handle duplicate-append scenario
          if (descriptionAppend?.trim()) {
            try {
              const currentDescription = existingIssue.description || '';

              // Build append section with metadata
              const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
              const channelName = 'Slack'; // TODO: Get from operation metadata when available
              const threadUrl = ''; // TODO: Get from operation metadata when available

              const appendSection = `\n\n---\n\n## Duplicate Reports\n\n### ${channelName} - ${timestamp}\n${threadUrl ? `${threadUrl}\n\n` : ''}**New context:**\n${descriptionAppend}`;

              // Update the description field with appended content
              updateFields.description = currentDescription + appendSection;
              descriptionUpdated = true;
            } catch (error) {
              logger.error('Failed to append context to duplicate ticket', {
                error,
                linearIssueId: issueId,
              });
              // Don't fail the whole operation if appending fails
            }
          }

          // Validate and transform data using Zod (converts null to undefined)
          const updateInput = LinearIssueUpdateInputSchema.parse(updateFields);

          // Only perform update if there are fields to update
          let updatedIssue;
          if (Object.keys(updateInput).length > 0) {
            const updatePayload = await this.client.updateIssue(issueId, updateInput);
            updatedIssue = await updatePayload.issue;
          } else {
            // No fields to update, reuse already-fetched issue details for display
            updatedIssue = existingIssue;
          }

          return {
            operation,
            success: true,
            linearIssueId: issueId,
            linearIssueIdentifier: updatedIssue?.identifier ?? undefined,
            linearIssueUrl: updatedIssue?.url ?? undefined,
            linearIssueTitle: updatedIssue?.title ?? undefined,
            descriptionUpdated,
          };
        }

        case TaskAction.SKIP: {
          // SKIP means no action needed - too vague, insufficient info, etc.
          // issueId should be null for true SKIP operations
          return {
            operation,
            success: true,
            linearIssueTitle: operation.skipData?.title,
          };
        }

        default:
          throw new Error(`Unknown operation action: ${operation.action}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error('Failed to execute Linear operation', {
        action: operation.action,
        issueId: operation.updateData?.issueId,
        title: operation.createData?.title ?? operation.skipData?.title,
        teamId: this.linearTeamId,
        error: errorMessage,
      });
      return {
        operation,
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Execute multiple Linear operations
   *
   * Processes all operations and returns a summary of results.
   *
   * @param operations - Array of operations to execute
   * @returns Summary with counts and individual results
   */
  async executeOperations(operations: LinearOperation[]): Promise<ExecutionSummary> {
    const results = await Promise.all(operations.map((op) => this.executeOperation(op)));

    return {
      totalOperations: operations.length,
      successful: results.filter((r) => r.success).length,
      failed: results.filter((r) => !r.success).length,
      results,
    };
  }
}
